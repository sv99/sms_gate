Шаблоны проектирования
======================

![Draw.io Domain Model Diagram](SMSGate_Domain_Model_draw.io.png)

Класс HTTPServer использует **обертку (wrapper)** для встраиваемого HTTP сервера
[mongoose](https://github.com/cesanta/mongoose) написанного на чистом С.

В реализации обертки (wrapper) для роутинга запросов от клиентов применяется шаблон **команда**.
Для обработки каждого зарегистрированного URL выбирается свой класс обработчик
унаследованный от WebController.

Пример реализации:
```c++
class MyController : public WebController
{
    public: 
        void hello(Request &request, StreamResponse &response)
        {
            response << "Hello " << htmlEntities(request.get("name", "... what's your name ?")) << endl;
        }

        void setup()
        {
            addRoute("GET", "/hello", MyController, hello);
        }
};
```

Обрабатываемые URL регистрируются при инициализации сервера:
```
MyController myController;
Server server(8080);
server.registerController(&myController);
```


При реализации класса GateController используется шаблон **фасад**, что позволяет сделать элементы системы отвечающие
за отправку СМС, слежение и обработку входящих СМС и Web интерфейс максимально независимыми, что облегчает тестирование
и уменьшает количество связей между подсистемами. Система в принципе не нагруженная и проблем, связанных с производительностью
из-за трансляции всех вызовов между подсистемами через фасадный класс скорее всего не будет.

При реализации InputWorker - подсистема проверяющая в отдельном потоке входящие СМС в папке input демона smsd -
реализует шаблон **наблюдатель** с pull стратегией на входе - чтение СМС по расписанию и push стратегию при
записи информации об СМС в базу данных и "проталкивании" сообщения в Web Интерфейс через WebSocket всем 
подкюченным клиентам.

